<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Three.js Stable Lighting (reads external data)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #ffffff; }
    #app { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
  <canvas id="app"></canvas>

  <!-- Your local three build & controls (same style as your project) -->
  <script src="../js/build/three.js"></script>
  <script src="../js/examples/js/controls/OrbitControls.js"></script>

  <!-- Load your data (must define global nTri and nodes) -->
  <script src="shellData_Y2e6_5sec_new.js"></script>

  <script>
  (function () {
    // ---- grab data from the external file (globals) ----
    if (typeof nTri === "undefined" || typeof nodes === "undefined") {
      console.error("Expected global nTri and nodes from shellData_Y2e6_5sec_new.js");
      return;
    }
    if (!Array.isArray(nodes)) {
      console.error("nodes must be a flat Array of numbers (length = frames * 9 * nTri)");
      return;
    }

    const canvas = document.getElementById("app");

    // ---- renderer ----
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    // nicer color/lighting response (works on r120+)
    if ("outputEncoding" in renderer) renderer.outputEncoding = THREE.sRGBEncoding;
    if ("toneMapping" in renderer) renderer.toneMapping = THREE.ACESFilmicToneMapping;
    if ("toneMappingExposure" in renderer) renderer.toneMappingExposure = 1.0;

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // ---- scene/camera/controls (Z-up) ----
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.up.set(0, 0, 1);
    camera.position.set(-20, -20, 12);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.update();

    // ---- lights: hemisphere (fill) + directional (shadow caster) ----
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.35);
    hemi.position.set(0, 0, 1);
    // scene.add(hemi);

	const ambientLight = new THREE.AmbientLight(0xffffff);
    ambientLight.intensity = 0.3;
    scene.add(ambientLight);

    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(60, -40, 120);
    sun.castShadow = true;

    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.near = 1;
    sun.shadow.camera.far  = 400;
    sun.shadow.camera.left = -150;
    sun.shadow.camera.right = 150;
    sun.shadow.camera.top = 150;
    sun.shadow.camera.bottom = -150;

    // Bias to fight shadow acne/peter-panning on thin shells
    sun.shadow.bias = -0.0005;       // tweak in [-0.0001, -0.002] if you see acne
    sun.shadow.normalBias = 0.02;    // helps with grazing angles
	sun.intensity = 0.1; 
    scene.add(sun);

    // ---- ground (visible) for stable shadows ----
    const groundGeo = new THREE.BoxGeometry(10000, 10000, 1);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0, metalness: 0.0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.position.set(0, 0, -15);
    ground.receiveShadow = true;
    scene.add(ground);

    // ---- data â†’ frames ----
    // Each triangle consumes 9 numbers (3 vertices * 3 coords).
    const triStride = 9;
    const perFrameCount = triStride * nTri;
    const totalFrames = Math.floor(nodes.length / perFrameCount);

    if (nodes.length % perFrameCount !== 0) {
      console.warn(
        "nodes.length is not a multiple of 9*nTri. " +
        "Some data may be ignored. length =", nodes.length,
        "perFrame =", perFrameCount
      );
    }

    // ---- material for the shell (PBR, no sparkly specular) ----
    const triMat = new THREE.MeshStandardMaterial({
    //   color: 0xffffff,
      color: 0x87CEEB,
      roughness: 0.85,
      metalness: 0.0,
      side: THREE.DoubleSide
    });

    // ---- state for the current frame mesh ----
    let triMesh = null;
    let frame = 0;

    function buildFrameMesh(frameIndex) {
      if (frameIndex >= totalFrames) return null;

      const triCount = nTri;
      const positions = new Float32Array(triCount * 3 * 3); // 3 verts/tri * 3 comps
      const indices   = new Uint32Array(triCount * 3);      // one face per tri

      const baseTri = frameIndex * nTri;
      let p = 0, idx = 0;

      for (let t = 0; t < triCount; t++) {
        // nodes are packed triangle-by-triangle
        const triIdx = baseTri + t;           // 0-based
        const off = triIdx * 9;

        const x1 = nodes[off + 0], y1 = nodes[off + 1], z1 = nodes[off + 2];
        const x2 = nodes[off + 3], y2 = nodes[off + 4], z2 = nodes[off + 5];
        const x3 = nodes[off + 6], y3 = nodes[off + 7], z3 = nodes[off + 8];

        positions[p++] = x1; positions[p++] = y1; positions[p++] = z1;
        positions[p++] = x2; positions[p++] = y2; positions[p++] = z2;
        positions[p++] = x3; positions[p++] = y3; positions[p++] = z3;

        const baseV = t * 3;
        indices[idx++] = baseV + 0;
        indices[idx++] = baseV + 1;
        indices[idx++] = baseV + 2;
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geom.setIndex(new THREE.BufferAttribute(indices, 1));
      geom.computeVertexNormals();

      const mesh = new THREE.Mesh(geom, triMat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    // ---- animation / frame advance ----
    const clock = new THREE.Clock();
    // change this to control playback speed for multi-frame data
    const framesPerSecond = 30;     // target playback
    const secondsPerFrame = 1 / framesPerSecond;
    let accTime = 0;

    function render() {
      const dt = clock.getDelta();
      accTime += dt;

      // build initial mesh
      if (!triMesh) {
        triMesh = buildFrameMesh(frame);
        if (triMesh) scene.add(triMesh);
      }

      // advance frames only if you actually have more than 1 frame
      if (totalFrames > 1) {
        while (accTime >= secondsPerFrame) {
          accTime -= secondsPerFrame;
          // dispose previous geometry safely
          if (triMesh) {
            triMesh.geometry.dispose();
            scene.remove(triMesh);
            triMesh = null;
          }
          frame = (frame + 1) % totalFrames;
          triMesh = buildFrameMesh(frame);
          if (triMesh) scene.add(triMesh);
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    // ---- resize ----
    window.addEventListener("resize", function () {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // quick sanity log
    console.log("nTri =", nTri, "nodes.length =", nodes.length, "frames =", totalFrames);

    render();
  })();
  </script>
</body>
</html>
