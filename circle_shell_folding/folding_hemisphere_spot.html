<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Three.js Stable Lighting (SpotLight, reads external data)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #ffffff; }
    #app { width: 100%; height: 100%; display: block; }
  </style>
</head>
<body>
  <canvas id="app"></canvas>

  <!-- Your local three build & controls -->
  <script src="../js/build/three.js"></script>
  <script src="../js/examples/js/controls/OrbitControls.js"></script>

  <!-- Load your data (must define global nTri and nodes) -->
  <script src="shellData_Y2e6_5sec_new.js"></script>

  <script>
  (function () {
    // ---- grab data from the external file (globals) ----
    if (typeof nTri === "undefined" || typeof nodes === "undefined") {
      console.error("Expected global nTri and nodes from shellData_Y2e6_5sec_new.js");
      return;
    }
    if (!Array.isArray(nodes)) {
      console.error("nodes must be a flat Array of numbers (length = frames * 9 * nTri)");
      return;
    }

    const canvas = document.getElementById("app");

    // ---- renderer ----
    const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    // nicer color/lighting response
    if ("outputEncoding" in renderer) renderer.outputEncoding = THREE.sRGBEncoding;
    if ("toneMapping" in renderer) renderer.toneMapping = THREE.ACESFilmicToneMapping;
    if ("toneMappingExposure" in renderer) renderer.toneMappingExposure = 0.85; // darker overall

    // enable physical falloff for spot decay
    renderer.physicallyCorrectLights = true;

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // ---- scene/camera/controls (Z-up) ----
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.up.set(0, 0, 1);
    camera.position.set(-20, -20, 20);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.update();

    // simpler intensity behavior (optional). If you keep it true, also OK.
    renderer.physicallyCorrectLights = false;

    // ---- lights: hemisphere (subtle fill) + spotlight (shadow caster) ----
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.15);
    hemi.position.set(0, 0, 1);
    scene.add(hemi);

    const spot = new THREE.SpotLight(0xffffff, 0.9); // visible but not harsh
    spot.position.set(30, -20, 90);
    spot.target.position.set(0, 0, 0);
    scene.add(spot.target);           // <-- IMPORTANT
    // --- lights ---
hemi.intensity = 0.10;

spot.intensity = 0.6;          // if physicallyCorrectLights=false
// spot.intensity = 12;         // use this instead if physicallyCorrectLights=true
spot.angle = 1;
spot.penumbra = 0.2;
spot.position.set(28, -18, 110);
// if using physical: spot.distance = 180; spot.decay = 2;

// shadows
spot.castShadow = true;
spot.shadow.mapSize.set(512, 512);
spot.shadow.camera.near = 8;
spot.shadow.camera.far  = 180;
spot.shadow.bias = -0.0006;
spot.shadow.normalBias = 0.025;


    scene.add(spot);

    // (debug helpers – uncomment to see the cone and shadow frustum)
    // const spotHelper = new THREE.SpotLightHelper(spot);
    // scene.add(spotHelper);
    // const camHelper = new THREE.CameraHelper(spot.shadow.camera);
    // scene.add(camHelper);


    // ---- ground (visible) for stable shadows ----
    const groundGeo = new THREE.BoxGeometry(10000, 10000, 1);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0, metalness: 0.0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.position.set(0, 0, -25);
    ground.receiveShadow = true;
    scene.add(ground);

    // ---- data → frames ----
    // Each triangle consumes 9 numbers (3 vertices * 3 coords).
    const triStride = 9;
    const perFrameCount = triStride * nTri;
    const totalFrames = Math.floor(nodes.length / perFrameCount);

    if (nodes.length % perFrameCount !== 0) {
      console.warn(
        "nodes.length is not a multiple of 9*nTri. " +
        "Some data may be ignored. length =", nodes.length,
        "perFrame =", perFrameCount
      );
    }

    // ---- material for the shell (cloth-like, less bright) ----
    const triMat = new THREE.MeshStandardMaterial({
    //   color: 0x87CEEB,    // sky blue; try 0xFFB6C1 for pink
      color: 0xFF69B4,
      roughness: 0.95,    // very matte
      metalness: 0.0,
      side: THREE.DoubleSide
    });

    // ---- state for the current frame mesh ----
    let triMesh = null;
    let frame = 0;

    function buildFrameMesh(frameIndex) {
      if (frameIndex >= totalFrames) return null;

      const triCount = nTri;
      const positions = new Float32Array(triCount * 3 * 3); // 3 verts/tri * 3 comps
      const indices   = new Uint32Array(triCount * 3);      // one face per tri

      const baseTri = frameIndex * nTri;
      let p = 0, idx = 0;

      for (let t = 0; t < triCount; t++) {
        // nodes are packed triangle-by-triangle
        const triIdx = baseTri + t;           // 0-based
        const off = triIdx * 9;

        const x1 = nodes[off + 0], y1 = nodes[off + 1], z1 = nodes[off + 2];
        const x2 = nodes[off + 3], y2 = nodes[off + 4], z2 = nodes[off + 5];
        const x3 = nodes[off + 6], y3 = nodes[off + 7], z3 = nodes[off + 8];

        positions[p++] = x1; positions[p++] = y1; positions[p++] = z1;
        positions[p++] = x2; positions[p++] = y2; positions[p++] = z2;
        positions[p++] = x3; positions[p++] = y3; positions[p++] = z3;

        const baseV = t * 3;
        indices[idx++] = baseV + 0;
        indices[idx++] = baseV + 1;
        indices[idx++] = baseV + 2;
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geom.setIndex(new THREE.BufferAttribute(indices, 1));
      geom.computeVertexNormals();

      const mesh = new THREE.Mesh(geom, triMat);
      mesh.castShadow = true;
      mesh.receiveShadow = false;
      return mesh;
    }

    // ---- animation / frame advance ----
    const clock = new THREE.Clock();
    const framesPerSecond = 30;
    const secondsPerFrame = 1 / framesPerSecond;
    let accTime = 0;

    function render() {
      const dt = clock.getDelta();
      accTime += dt;

      if (!triMesh) {
        triMesh = buildFrameMesh(frame);
        if (triMesh) scene.add(triMesh);
      }

      if (totalFrames > 1) {
        while (accTime >= secondsPerFrame) {
          accTime -= secondsPerFrame;
          if (triMesh) {
            triMesh.geometry.dispose();
            scene.remove(triMesh);
            triMesh = null;
          }
          frame = (frame + 1) % totalFrames;
          triMesh = buildFrameMesh(frame);
          if (triMesh) scene.add(triMesh);
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    // ---- resize ----
    window.addEventListener("resize", function () {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // quick sanity log
    console.log("nTri =", nTri, "nodes.length =", nodes.length, "frames =", totalFrames);

    render();
  })();
  </script>
</body>
</html>
