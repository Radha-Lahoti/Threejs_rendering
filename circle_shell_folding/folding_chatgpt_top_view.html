<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Three.js — Top View + Soft Spot + Smooth + Auto CCapture</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#ffffff; }
    #app { width:100%; height:100%; display:block; }
  </style>
</head>
<body>
  <canvas id="app"></canvas>

  <!-- three.js (non-module) + controls -->
  <script src="../js/build/three.js"></script>
  <script src="../js/examples/js/controls/OrbitControls.js"></script>
  <!-- BufferGeometryUtils (non-module: attaches THREE.BufferGeometryUtils) -->
  <script src="../js/examples/js/utils/BufferGeometryUtils.js"></script>

  <!-- CCapture -->
  <script src="../ccapture.js-master/build/CCapture.all.min.js"></script>

  <!-- Load your data (defines nTri and nodes) -->
  <!-- <script src="shellData_Y2e7_5sec_new.js"></script> -->
  <script src="shellData_Y2e6_5sec_new.js"></script>

  <script>
  (function () {
    if (typeof nTri === "undefined" || typeof nodes === "undefined" || !Array.isArray(nodes)) {
      console.error("Expected global nTri and nodes[] from your data .js");
      return;
    }

    // --- canvas / renderer ---
    const canvas = document.getElementById("app");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, preserveDrawingBuffer:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.7;
    renderer.physicallyCorrectLights = false;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // --- scene / camera / controls (Z-up) ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xE7E7E7);

    // Parent for model so we can roll it 90° CCW in top view
    const modelRoot = new THREE.Group();
    modelRoot.rotation.z = Math.PI / 2; // 90° anticlockwise (use -Math.PI/2 for clockwise)
    scene.add(modelRoot);

    // Top view camera (looking down +Z)
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.up.set(0,0,1);
    camera.position.set(0, 0, 30);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0,0,0);
    controls.update();

    // --- lights: subtle hemi + soft spotlight ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.10);
    hemi.position.set(0,0,1);
    scene.add(hemi);

    const spot = new THREE.SpotLight(0xffffff, 0.42);
    spot.position.set(28, -18, 120);
    spot.target.position.set(0,0,0);
    scene.add(spot.target);
    spot.angle = 0.42;
    spot.penumbra = 0.9;
    spot.castShadow = true;
    spot.shadow.mapSize.set(2048, 2048);
    spot.shadow.camera.near = 8;
    spot.shadow.camera.far  = 180;
    spot.shadow.bias = -0.0006;
    spot.shadow.normalBias = 0.025;
    spot.shadow.radius = 3;
    scene.add(spot);

    // --- Z-up shadow-catcher ground (no rotation) ---
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(10000, 10000),
      new THREE.ShadowMaterial({ opacity: 0.28 })
    );
    ground.position.set(0,0,-15);
    ground.receiveShadow = true;
    scene.add(ground);

    // --- data → frames ---
    const triStride = 9;
    const perFrameCount = triStride * nTri;
    const totalFrames = Math.floor(nodes.length / perFrameCount);

    // --- cloth material (matte) ---
    const triMat = new THREE.MeshStandardMaterial({
      color: 0xFF69B4,     // HotPink; try 0xFFB6C1 or 0x6FA9C9
      roughness: 0.98,
      metalness: 0.0,
      side: THREE.DoubleSide,
      flatShading: false
    });

    // --- build smooth mesh for a frame ---
    function buildFrameMesh(frameIndex) {
      if (frameIndex >= totalFrames) return null;

      const triCount = nTri;
      const positions = new Float32Array(triCount * 3 * 3);
      const indices   = new Uint32Array(triCount * 3);

      const baseTri = frameIndex * nTri;
      let p = 0, idx = 0;

      for (let t = 0; t < triCount; t++) {
        const off = (baseTri + t) * 9;
        positions[p++] = nodes[off + 0]; positions[p++] = nodes[off + 1]; positions[p++] = nodes[off + 2];
        positions[p++] = nodes[off + 3]; positions[p++] = nodes[off + 4]; positions[p++] = nodes[off + 5];
        positions[p++] = nodes[off + 6]; positions[p++] = nodes[off + 7]; positions[p++] = nodes[off + 8];

        const baseV = t * 3;
        indices[idx++] = baseV + 0;
        indices[idx++] = baseV + 1;
        indices[idx++] = baseV + 2;
      }

      let geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geom.setIndex(new THREE.BufferAttribute(indices, 1));

      // Smooth shading: weld close verts, then normals (lower tolerance = less smoothing)
      if (THREE.BufferGeometryUtils && THREE.BufferGeometryUtils.mergeVertices) {
        geom = THREE.BufferGeometryUtils.mergeVertices(geom, 1e-8);
      }
      geom.computeVertexNormals();

      const mesh = new THREE.Mesh(geom, triMat);
      mesh.castShadow = true;
      mesh.receiveShadow = false; // avoid self-shadow blotches
      return mesh;
    }

    // ---------- CCAPTURE: auto start, auto stop & save ----------
    const fps = 30; // exported framerate metadata
    const capturer = new CCapture({
      format: "png",
      framerate: fps,
      name: "frames",
      verbose: true
    });

    let triMesh = null;
    let frameIndex = 0;
    let startedCapture = false;

    function stepAndCapture() {
      if (!startedCapture) { capturer.start(canvas); startedCapture = true; }

      // swap mesh for this frame
      if (triMesh) {
        triMesh.geometry.dispose();
        modelRoot.remove(triMesh);
        triMesh = null;
      }
      triMesh = buildFrameMesh(frameIndex);
      if (triMesh) modelRoot.add(triMesh); // <-- add to rotated parent

      // render & capture
      renderer.render(scene, camera);
      capturer.capture(canvas);

      frameIndex++;
      if (frameIndex < totalFrames) {
        requestAnimationFrame(stepAndCapture);
      } else {
        capturer.stop();
        capturer.save();
        console.log("Saved", totalFrames, "frames.");
      }
    }

    // start auto export immediately
    requestAnimationFrame(stepAndCapture);

    // --- resize ---
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    console.log("nTri =", nTri, "nodes.length =", nodes.length, "frames =", totalFrames);
  })();
  </script>
</body>
</html>
