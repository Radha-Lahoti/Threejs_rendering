<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - ShadowMapViewer example </title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
		</style>
	</head>
	<body>
		
		
		<canvas id="myCanvas" style="font-family: Monospace;
				background-color: #000; color: #fff; margin: 0px; overflow: hidden;">
			
		<script src="../js/build/three.js"></script>
		<script src="../js/examples/js/controls/OrbitControls.js"></script>
		<script src="../js/examples/js/shaders/UnpackDepthRGBAShader.js"></script>
		<script src="../js/examples/js/utils/ShadowMapViewer.js"></script>
		<script src="../js/examples/js/WebGL.js"></script>
		<script src="../js/examples/js/libs/stats.min.js"></script>

		<script src="../ccapture.js-master/build/CCapture.all.min.js"></script>

		<!-- <script src="rodData.js"></script> -->
		 <script src="rodData_no_friction.js"></script>
		
		
		<script>

			var camera, scene, renderer, clock, stats;
			var dirLight, spotLight;
			var cube;
			var rod, nodesRod;
			var rodGroup;
			var nNodes, nTimes, rodRadius, sphereRadius;
			var globalCounter = 0;
			var imgCounter = 1;
			var renderNodes = 200;

			// Create a capturer that exports PNG images in a TAR file
			var capturer = new CCapture( { format: 'png' } );
			var canvas = document.getElementById("myCanvas");

			init();
			animate();


			function CustomSinCurve( scale ) {
				THREE.Curve.call( this );
				this.scale = ( scale === undefined ) ? 1 : scale;
			}

			function init() {

				initScene();
				initMisc();

				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );


				var i;
				nTimes = nodesRod.length / (5 * nNodes);				
			}

			function initScene() {

				camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 1, 1000 );
				// Change the following line to change the "boundary" of the scene (important line)	
				camera.position.set( 0, 70, 20 );

				// camera.position.set(0, 0, 50);
                camera.up = new THREE.Vector3( 0, 0, 1 );

				camera.lookAt(0, 0, 0);

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );

				// Lights

				spotLight = new THREE.SpotLight( 0x9090b0 );
				spotLight.name = 'Spot Light';
				spotLight.angle = 0.9;
				spotLight.penumbra = 0.5;
				// // spotLight.position.set( 40, 100, -90 );
				spotLight.position.set(50, 50, 200);
				// spotLight.position.set(0, 50, 20);
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 50;
				spotLight.shadow.camera.far = 350;
				spotLight.shadow.mapSize.width = 10240;
				spotLight.shadow.mapSize.height = 10240;
				scene.add( spotLight );

				var light = new THREE.AmbientLight( 0x808080 ); // soft white light
				scene.add( light );

				// scene.add( new THREE.CameraHelper( spotLight.shadow.camera ) );

				// dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
				// dirLight.name = 'Dir. Light';
				// dirLight.position.set( 0, 10, -100 );
				// dirLight.castShadow = true;
				// dirLight.shadow.camera.near = 1;
				// dirLight.shadow.camera.far = 100;
				// dirLight.shadow.camera.right = 150;
				// dirLight.shadow.camera.left = - 150;
				// dirLight.shadow.camera.top	= 150;
				// dirLight.shadow.camera.bottom = - 150;
				// dirLight.shadow.mapSize.width = 10240;
				// dirLight.shadow.mapSize.height = 10240;
				// scene.add( dirLight );

				// scene.add( new THREE.CameraHelper( dirLight.shadow.camera ) );

				// add cube
				// var geometry = new THREE.BoxGeometry( 3, 3, 3 );
				// cube = new THREE.Mesh( geometry, material );
				// cube.position.set( 8, 3, 8 );
				// cube.castShadow = true;
				// cube.receiveShadow = true;
				// scene.add( cube );
				
				// var sphereGeom =  new THREE.SphereGeometry( sphereRadius, 32, 32 );
				// SphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)
				// var blueMaterial = new THREE.MeshBasicMaterial( { color: 0x0000ff, transparent: true, opacity: 0.4 } );
				// var sphere = new THREE.Mesh( sphereGeom, blueMaterial );
				// sphere.castShadow = true;
				// sphere.position.set( 0, 0, 0 );
				// scene.add( sphere );
				
				// PIYUSH START
				// dirLight = new THREE.DirectionalLight( 0x999999,0.4);
				// dirLight.name = 'Dir. Light';
				// dirLight.position.set( 0, 10, 0 );
				// dirLight.target.position.set( 10, 0, 10 );
				// dirLight.castShadow = true;
				// dirLight.shadow.camera.near = 8;
				// dirLight.shadow.camera.far = 200;
				// dirLight.shadow.camera.right = 150;
				// dirLight.shadow.camera.left = - 150;
				// dirLight.shadow.camera.top	= 150;
				// dirLight.shadow.camera.bottom = - 150;				
				// dirLight.shadow.mapSize.width = 10240;
				// dirLight.shadow.mapSize.height = 10240;
				// scene.add( dirLight );	

				// spotLight = new THREE.SpotLight( 0x9090b0 );
				// spotLight.name = 'Spot Light';
				// spotLight.angle = 2.5;
				// spotLight.penumbra = 0.5;
				// // spotLight.position.set( 40, 100, -90 );
				// // spotLight.position.set(-250, 120, 600);
				// // spotLight.position.set(-250, 120, 600);
				// spotLight.position.set(50, 50, 200);
				// spotLight.castShadow = true;
				// spotLight.shadow.camera.near = 50;
				// spotLight.shadow.camera.far = 350;
				// spotLight.shadow.mapSize.width = 10240;
				// spotLight.shadow.mapSize.height = 10240;
				// scene.add( spotLight );
				//PIYUSH END
				// Add ground
				var groundgeometry = new THREE.BoxGeometry( 500, 500.0, 1.0 );
				var groundmaterial = new THREE.MeshPhongMaterial( {
					color: 0xD6F5FF,
					shininess: 0,
					specular: 0x000000
				} );
				var ground = new THREE.Mesh( groundgeometry, groundmaterial );
				ground.scale.multiplyScalar( 1 );
				// ground.position.set( -100, -35, -30 );
				ground.position.set( -100, -35, -0.6 );
				ground.castShadow = false;
				ground.receiveShadow = true;
				scene.add( ground );

				// Add Top Lid
				// var topLidgeometry = new THREE.BoxGeometry( 50, 20, 20 );
				// var topLidcolor = new THREE.Color("rgb(50, 50, 50)");
				// var topLidmaterial = new THREE.MeshPhongMaterial( {
				// 	color: topLidcolor,
				// 	shininess: 0,
				// 	specular: 0xdddddd
				// } );

				// var topLid = new THREE.Mesh( topLidgeometry, topLidmaterial );
				// topLid.scale.multiplyScalar( 1 );
				// topLid.position.set( -58, 0, 0 );
				// topLid.castShadow = true;
				// topLid.receiveShadow = false;
				// scene.add( topLid );
			}

			function initMisc() {

				renderer = new THREE.WebGLRenderer({
							canvas: canvas, 
							antialias: true,
                    		preserveDrawingBuffer: true
                	});
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				// renderer.shadowMap.type = THREE.BasicShadowMap;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;

				// Mouse control
				var controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 2, 0 );
				controls.update();

				clock = new THREE.Clock();

				stats = new Stats();
				document.body.appendChild( stats.dom );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {

				requestAnimationFrame( animate );				
				
				if (globalCounter == 1)
				{
					capturer.start( canvas );
				}
				
				if (globalCounter>0 && globalCounter < nTimes)
				{
					capturer.capture( canvas );
					// console.log(globalCounter);
					// console.log(nTimes);
					// takeScreenshot(globalCounter);
				}				
				render();
				stats.update();
				
				if (globalCounter == nTimes-1)
				{
					capturer.stop();
					capturer.save();
				}		
			}

			function takeScreenshot( imgNumber ) {
				//
				// Make sure that pop-ups are allowed from this site
				//
				
			    // For screenshots to work with WebGL renderer, preserveDrawingBuffer should be set to true.
			    // open in new window like this
					var w = window.open('', '');
	    			w.document.title = "Screenshot";
	    			//w.document.body.style.backgroundColor = "red";
	    			var img = new Image();
	    			img.src = renderer.domElement.toDataURL();
	    			w.document.body.appendChild(img);

			    	// download file like this.
			    	var a = document.createElement('a');
				a.href = renderer.domElement.toDataURL().replace("image/png", "image/octet-stream");
			    a.download = imgCounter.toString().padStart(10, "0") + '.png'
				a.click();
				
				imgCounter = imgCounter + 1;
				
				w.close();
			}

			function renderScene() {

				renderer.render( scene, camera );

			}

			function render() {
                const delta = clock.getDelta();
                renderScene();

                if (globalCounter <= nTimes-1)
                    scene.remove(rodGroup);

                const xOffset = -20; // Shift rod leftward to center it in the view

                CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
                CustomSinCurve.prototype.constructor = CustomSinCurve;

                CustomSinCurve.prototype.getPoint = function ( t ) {
                    var baseNum = globalCounter * 5 * nNodes;
                    if (baseNum > nodesRod.length) {
                        return new THREE.Vector3(0,0,0);
                    }

                    var indRight = t * (nNodes-1);
                    var indf = Math.floor( indRight );
                    var indc = Math.ceil( indRight );
                    var df = indRight - indf;
                    var dc = - indRight + indc;
                    if (df < 1/(100*renderNodes)) {
                        df = 1.0;
                        dc = 0.0;
                    }
                    var tx = nodesRod[5*indf+2 + baseNum] * dc + nodesRod[5*indc+2 + baseNum] * df;
                    var ty = nodesRod[5*indf+3 + baseNum] * dc + nodesRod[5*indc+3 + baseNum] * df;
                    var tz = nodesRod[5*indf+4 + baseNum] * dc + nodesRod[5*indc+4 + baseNum] * df;

                    return new THREE.Vector3( tx + xOffset, ty, tz ).multiplyScalar( this.scale );
                };

                rodGroup = new THREE.Group();

                var nRodsThisStep = 1;
                var addRods;
                do {
                    var cTime = nodesRod[globalCounter * 5 * nNodes];
                    var nextTime;
                    var nextTimeInd = (globalCounter + nRodsThisStep) * 5 * nNodes;
                    addRods = 0;
                    if (nextTimeInd < nodesRod.length) {
                        nextTime = nodesRod[nextTimeInd];
                        if (cTime == nextTime) {
                            nRodsThisStep++;
                            addRods = 1;
                        }
                    }
                } while (addRods == 1);

                for (let i = 0; i < nRodsThisStep; i++) {
                    var path = new CustomSinCurve( 1 );
                    var geometry = new THREE.TubeGeometry( path, 200, rodRadius, 12, false );

                    let material;
                    if (i === 0) {
                        material = new THREE.MeshPhongMaterial({
                            color: 0xA4653A,
                            shininess: 150,
                            specular: 0x222222
                        });
                    } else if (i === 1) {
                        material = new THREE.MeshPhongMaterial({
                            color: 0xff0000,
                            shininess: 150,
                            specular: 0x222222
                        });
                    }

                    rod = new THREE.Mesh( geometry, material );
                    rod.castShadow = true;
                    rod.receiveShadow = true;
                    rodGroup.add( rod );

                    let sphereColor = (i === 0) ? new THREE.Color(0xA4653A).multiplyScalar(0.6) : new THREE.Color(0xff0000).multiplyScalar(0.6);
                    let sphereMaterial = new THREE.MeshPhongMaterial({
                        color: sphereColor,
                        shininess: 30,
                        specular: 0x111111
                    });
                    let sphereGeom = new THREE.SphereGeometry( rodRadius * 2, 32, 32 );

                    let baseNum = (globalCounter + i) * 5 * nNodes;

                    for (let j = 0; j < nNodes; j++) {
                        let x = nodesRod[5 * j + 2 + baseNum];
                        let y = nodesRod[5 * j + 3 + baseNum];
                        let z = nodesRod[5 * j + 4 + baseNum];

                        let sphere = new THREE.Mesh(sphereGeom, sphereMaterial);
                        sphere.position.set(x + xOffset, y, z);
                        sphere.castShadow = true;
                        sphere.receiveShadow = true;

                        rodGroup.add(sphere);
                    }

                    globalCounter++;
                }

                scene.add( rodGroup );
            }


		</script>
		</div>
	</body>
</html>

